Here’s the big picture of what we’re building—what it is, why it matters, and how all the parts fit together.

We’re turning an Android phone into a full-blown radio transmitter for FPV/RC, driving a 2.4 GHz ExpressLRS (ELRS) module over USB-OTG. Instead of a traditional handheld radio with gimbals, the phone becomes the “TX brain”: it reads pilot inputs (from a gamepad or touch), generates CRSF channel frames at a steady high rate, and streams those frames to the ELRS SuperG TX module (your BETAFPV unit, which enumerates as a Silicon Labs CP2102 USB-UART). The ELRS module then handles the over-the-air link to your quad (e.g., the Flywoo LR4). If we do this right, you plug a controller and the ELRS module into your phone, launch the app, grant USB permission, and you can fly—no laptop, no OpenTX/EdgeTX radio required.

The project is intentionally minimalist and native. On Android side, we’re not using heavy cross-platform toolkits or fancy engines; we keep to a simple Activity with a heads-up display (HUD) and an NDK C++ core loop. The Java/Kotlin layer (we stuck to Java for simplicity) manages the Android-specific concerns: USB permissions, device enumeration, hot-plug/teardown, and reading HID gamepad events. All traffic to the ELRS module goes through Android’s `UsbManager` API using bulk endpoints (OUT for write, IN if we later read telemetry), not root hacks. That means the app should work on stock ROMs, though you’re on LineageOS, which is fine as long as USB host mode is solid.

Under the hood, the most critical piece is the C++ transmitter loop. It runs in a detached thread and ticks at roughly 250 Hz (i.e., one frame every \~4 ms). On each tick, it samples the latest stick values that the Activity provides (roll, pitch, yaw, and throttle), packs them into a CRSF “RC Channels” payload (16 channels at 11 bits each, little-endian bit-packed), wraps the payload in the CRSF frame header/trailer (device address, length, type, and CRC), and passes that byte array back to Java through JNI. Java then pushes the bytes out the bulk OUT endpoint associated with the CP2102 interface. We initialize the CP2102 with the standard sequence (set line coding and control lines) and use a high UART rate (e.g., 460 800 bps), which is typical for ELRS serial back-ends. The ELRS module converts that UART/CRSF feed into over-the-air packets with its own timing and RF stack.

On the input side, we’re reading a USB/Bluetooth gamepad (your 8BitDo) via Android’s regular input pipeline. `onGenericMotionEvent` gives us analog axes like `AXIS_X/AXIS_Y` (left stick), `AXIS_RX/AXIS_RY` (right stick), `AXIS_RZ` or analog triggers for throttle, and so on. We normalize these to the RC domain: sticks map to ±1.0 around center, throttle maps to 0.0–1.0, then the C++ code converts to CRSF channel values (172–1811 range) with a linear 1000–2000 µs mapping under the hood. We add a small deadzone to avoid drift. This approach means any standards-compliant HID gamepad “just works”—no device-specific SDKs.

The Activity itself stays full-screen and “immersive” to avoid Android navigation gestures interfering while you fly. The HUD shows a line or two of status (“USB: connected,” VID\:PID list, endpoint types, permission prompts) and live readouts of the four primary RC channels so you can check that input → CRSF path is alive before arming a quad. Because we’re dealing with USB permission broadcasts on Android 13+, we register our receiver with the proper `RECEIVER_NOT_EXPORTED` flag when dynamic-registering, and we also include an optional manifest receiver that can auto-launch the app when a matching USB device is attached (using a broad `device_filter.xml` so common chips like CP210x and CH34x trigger it). We listen for `ATTACHED`/`DETACHED` to auto-recover if a cable wiggles loose.

LineageOS adds a practical twist: some builds don’t expose a user-facing “OTG toggle,” and power management can be stricter. For reliability, we plan around powered OTG hubs/Y-cables and check for bulk endpoints rather than hard-coding vendor IDs. Your device list (10c4\:ea60 CP2102 for the ELRS module, 2dc8:301f for the 8BitDo, 1a86:8091 hub) confirms the kernel sees everything; our app adapts at runtime by scanning all interfaces/endpoints and picking the one that offers bulk OUT.

Why do this at all? Flexibility and portability. Phones have great screens, batteries, CPUs, connectivity, and sensors. A “phone-as-radio” lets you integrate OSD/HUD, recording, voice prompts, maps, and even networked control (careful…) in one device. For travel or quick test flights, you can bring a tiny ELRS module and a compact gamepad instead of a full-size transmitter. It’s also a neat gateway for developers to explore ELRS/CRSF without learning a radio firmware.

There are important boundaries. First, this is not about bypassing safety. You should only fly where and how it’s legal, keep VLOS as required, and test on the bench with props off. Second, phone USB power can be marginal; brown-outs cause weird disconnects. We recommend a short, high-quality OTG adapter and, if instability appears, a powered hub. Third, latency matters. We’re keeping the app lightweight, avoiding unnecessary garbage collection pressure, and sending frames at a steady cadence. In practice, the radio link’s latency dominates, but sloppy app loops can add jitter; we’ll keep measuring and optimizing.

From here, the roadmap is clear. On the input side, we’ll add calibration, expo/rates, channel mapping (aux modes, arming, beeper), and support for more devices (BLE gamepads, USB wheels/sticks). On output, we can expose a settings pane for packet rate presets (matching ELRS 150/250/500 Hz modes), dynamic idle for throttle shaping, and model memories (per-quad profiles). We can also read IN endpoints for telemetry: CRSF telemetry packets contain link quality, RSSI, SNR, battery voltage, GPS, and more—perfect for an Android OSD overlay. Since we’re already native, we can later draw nicer bars and artificial horizon without pulling in large UI toolkits.

We’ll also add robust logging: enumerate all devices with interface/endpoint dumps on startup, log every permission grant/deny, and show a concise “Open failed: reason” message (no bulk endpoints found, interface claim failed, control transfer failed, etc.). That helps diagnose ROM- or cable-specific issues quickly.

Finally, there’s room for advanced experiments: mapping the phone’s IMU as a control source (tilt-to-fly), on-screen joysticks for emergency use, or network relay (phone connects to a ground station that tunnels CRSF—only in controlled environments). We can even build a small touch-configurator for the ELRS module, using its serial CLI or passthrough, to set power, packet rate, or Wi-Fi update mode without leaving the app.

In short, we’re building a lean, reliable bridge from **Android inputs → CRSF frames → ELRS module**, with a clean separation of concerns: Java handles Android services and USB plumbing; C++ does the tight-loop packing and timing. The result is a pocketable, flexible transmitter that’s easy to extend and debug—something you can use in the field with just a phone, a gamepad, and your SuperG.

Here’s the big picture of what we’re building—what it is, why it matters, and how all the parts fit together.

We’re turning an Android phone into a full-blown radio transmitter for FPV/RC, driving a 2.4 GHz ExpressLRS (ELRS) module over USB-OTG. Instead of a traditional handheld radio with gimbals, the phone becomes the “TX brain”: it reads pilot inputs (from a gamepad or touch), generates CRSF channel frames at a steady high rate, and streams those frames to the ELRS SuperG TX module (your BETAFPV unit, which enumerates as a Silicon Labs CP2102 USB-UART). The ELRS module then handles the over-the-air link to your quad (e.g., the Flywoo LR4). If we do this right, you plug a controller and the ELRS module into your phone, launch the app, grant USB permission, and you can fly—no laptop, no OpenTX/EdgeTX radio required.

The project is intentionally minimalist and native. On Android side, we’re not using heavy cross-platform toolkits or fancy engines; we keep to a simple Activity with a heads-up display (HUD) and an NDK C++ core loop. The Java/Kotlin layer (we stuck to Java for simplicity) manages the Android-specific concerns: USB permissions, device enumeration, hot-plug/teardown, and reading HID gamepad events. All traffic to the ELRS module goes through Android’s `UsbManager` API using bulk endpoints (OUT for write, IN if we later read telemetry), not root hacks. That means the app should work on stock ROMs, though you’re on LineageOS, which is fine as long as USB host mode is solid.

Under the hood, the most critical piece is the C++ transmitter loop. It runs in a detached thread and ticks at roughly 250 Hz (i.e., one frame every \~4 ms). On each tick, it samples the latest stick values that the Activity provides (roll, pitch, yaw, and throttle), packs them into a CRSF “RC Channels” payload (16 channels at 11 bits each, little-endian bit-packed), wraps the payload in the CRSF frame header/trailer (device address, length, type, and CRC), and passes that byte array back to Java through JNI. Java then pushes the bytes out the bulk OUT endpoint associated with the CP2102 interface. We initialize the CP2102 with the standard sequence (set line coding and control lines) and use a high UART rate (e.g., 460 800 bps), which is typical for ELRS serial back-ends. The ELRS module converts that UART/CRSF feed into over-the-air packets with its own timing and RF stack.

On the input side, we’re reading a USB/Bluetooth gamepad (your 8BitDo) via Android’s regular input pipeline. `onGenericMotionEvent` gives us analog axes like `AXIS_X/AXIS_Y` (left stick), `AXIS_RX/AXIS_RY` (right stick), `AXIS_RZ` or analog triggers for throttle, and so on. We normalize these to the RC domain: sticks map to ±1.0 around center, throttle maps to 0.0–1.0, then the C++ code converts to CRSF channel values (172–1811 range) with a linear 1000–2000 µs mapping under the hood. We add a small deadzone to avoid drift. This approach means any standards-compliant HID gamepad “just works”—no device-specific SDKs.

The Activity itself stays full-screen and “immersive” to avoid Android navigation gestures interfering while you fly. The HUD shows a line or two of status (“USB: connected,” VID\:PID list, endpoint types, permission prompts) and live readouts of the four primary RC channels so you can check that input → CRSF path is alive before arming a quad. Because we’re dealing with USB permission broadcasts on Android 13+, we register our receiver with the proper `RECEIVER_NOT_EXPORTED` flag when dynamic-registering, and we also include an optional manifest receiver that can auto-launch the app when a matching USB device is attached (using a broad `device_filter.xml` so common chips like CP210x and CH34x trigger it). We listen for `ATTACHED`/`DETACHED` to auto-recover if a cable wiggles loose.

LineageOS adds a practical twist: some builds don’t expose a user-facing “OTG toggle,” and power management can be stricter. For reliability, we plan around powered OTG hubs/Y-cables and check for bulk endpoints rather than hard-coding vendor IDs. Your device list (10c4\:ea60 CP2102 for the ELRS module, 2dc8:301f for the 8BitDo, 1a86:8091 hub) confirms the kernel sees everything; our app adapts at runtime by scanning all interfaces/endpoints and picking the one that offers bulk OUT.

Why do this at all? Flexibility and portability. Phones have great screens, batteries, CPUs, connectivity, and sensors. A “phone-as-radio” lets you integrate OSD/HUD, recording, voice prompts, maps, and even networked control (careful…) in one device. For travel or quick test flights, you can bring a tiny ELRS module and a compact gamepad instead of a full-size transmitter. It’s also a neat gateway for developers to explore ELRS/CRSF without learning a radio firmware.

There are important boundaries. First, this is not about bypassing safety. You should only fly where and how it’s legal, keep VLOS as required, and test on the bench with props off. Second, phone USB power can be marginal; brown-outs cause weird disconnects. We recommend a short, high-quality OTG adapter and, if instability appears, a powered hub. Third, latency matters. We’re keeping the app lightweight, avoiding unnecessary garbage collection pressure, and sending frames at a steady cadence. In practice, the radio link’s latency dominates, but sloppy app loops can add jitter; we’ll keep measuring and optimizing.

From here, the roadmap is clear. On the input side, we’ll add calibration, expo/rates, channel mapping (aux modes, arming, beeper), and support for more devices (BLE gamepads, USB wheels/sticks). On output, we can expose a settings pane for packet rate presets (matching ELRS 150/250/500 Hz modes), dynamic idle for throttle shaping, and model memories (per-quad profiles). We can also read IN endpoints for telemetry: CRSF telemetry packets contain link quality, RSSI, SNR, battery voltage, GPS, and more—perfect for an Android OSD overlay. Since we’re already native, we can later draw nicer bars and artificial horizon without pulling in large UI toolkits.

We’ll also add robust logging: enumerate all devices with interface/endpoint dumps on startup, log every permission grant/deny, and show a concise “Open failed: reason” message (no bulk endpoints found, interface claim failed, control transfer failed, etc.). That helps diagnose ROM- or cable-specific issues quickly.

Finally, there’s room for advanced experiments: mapping the phone’s IMU as a control source (tilt-to-fly), on-screen joysticks for emergency use, or network relay (phone connects to a ground station that tunnels CRSF—only in controlled environments). We can even build a small touch-configurator for the ELRS module, using its serial CLI or passthrough, to set power, packet rate, or Wi-Fi update mode without leaving the app.

In short, we’re building a lean, reliable bridge from **Android inputs → CRSF frames → ELRS module**, with a clean separation of concerns: Java handles Android services and USB plumbing; C++ does the tight-loop packing and timing. The result is a pocketable, flexible transmitter that’s easy to extend and debug—something you can use in the field with just a phone, a gamepad, and your SuperG.

